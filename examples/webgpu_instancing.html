<html lang="en">
	<head>
		<title>WebGPU Instance</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>
		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> WebGPU - Instance<br/>(Chrome Canary with flag: --enable-unsafe-webgpu)
		</div>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import WebGPURenderer from './jsm/renderers/webgpu/WebGPURenderer.js';
			import WebGPU from './jsm/renderers/webgpu/WebGPU.js';

			import { 
				Matrix3Uniform,
				Matrix4Uniform
			} from './jsm/renderers/webgpu/WebGPUUniform.js';
			import WebGPUStorageBuffer from './jsm/renderers/webgpu/WebGPUStorageBuffer.js';
			import WebGPUUniformsGroup from './jsm/renderers/webgpu/WebGPUUniformsGroup.js';

			let camera, scene, renderer;
			let pointer;

			const computeParams = [];

			init().then( animate ).catch( error );

			async function init() {

				if ( WebGPU.isAvailable() === false ) {

					document.body.appendChild( WebGPU.getErrorMessage() );

					throw 'No WebGPU support';

				}

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera.position.z = 12;

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x000000 );

				const particleNum = 1024 * 128;
				const particleSize = 3;

				const particleArray = new Float32Array( particleNum * particleSize );
				const velocityArray = new Float32Array( particleNum * particleSize );
				const colorArray = new Float32Array( particleNum * particleSize );

				for ( let i = 0; i < particleArray.length / particleSize; i ++ ) {

					const r = Math.random() * 0.02 + 0.02;
					const rad = Math.random() * Math.PI;
					const rad2 = Math.random() * Math.PI * 2.0;

					velocityArray[ i * particleSize + 0 ] = r * Math.sin( rad ) * Math.cos( rad2 );
					velocityArray[ i * particleSize + 1 ] = r * Math.sin( rad ) * Math.sin( rad2 );
					velocityArray[ i * particleSize + 2 ] = r * Math.cos( rad );

					colorArray[ i * 3 + 0 ] = Math.random() * 0.7 + 0.3;
					colorArray[ i * 3 + 1 ] = Math.random() * 0.7 + 0.3;
					colorArray[ i * 3 + 2 ] = Math.random() * 0.7 + 0.3;

				}

				const particleAttribute = new THREE.InstancedBufferAttribute( particleArray, particleSize );
				const velocityAttribute = new THREE.BufferAttribute( velocityArray, particleSize );
				const colorAttribute = new THREE.InstancedBufferAttribute( colorArray, 3 );

				const particleBuffer = new WebGPUStorageBuffer( 'particle', particleAttribute );
				const velocityBuffer = new WebGPUStorageBuffer( 'velocity', velocityAttribute );
		
				const computeBindings = [
					particleBuffer,
					velocityBuffer
				];

				const computeShader = `#version 450
					#define PARTICLE_NUM ${particleNum}
					#define PARTICLE_SIZE ${particleSize}
					#define ROOM_SIZE 4.0

					// Limitation for now: the order should be the same as bindings order

					layout(set = 0, binding = 0) buffer Particle {
						float particle[ PARTICLE_NUM * PARTICLE_SIZE ];
					} particle;

					layout(set = 0, binding = 1) buffer Velocity {
						float velocity[ PARTICLE_NUM * PARTICLE_SIZE ];
					} velocity;

					void main() {
						uint index = gl_GlobalInvocationID.x;
						if ( index >= PARTICLE_NUM ) { return; }

						vec3 position = vec3(
							particle.particle[ index * PARTICLE_SIZE + 0 ] + velocity.velocity[ index * PARTICLE_SIZE + 0 ],
							particle.particle[ index * PARTICLE_SIZE + 1 ] + velocity.velocity[ index * PARTICLE_SIZE + 1 ],
							particle.particle[ index * PARTICLE_SIZE + 2 ] + velocity.velocity[ index * PARTICLE_SIZE + 2 ]
						);

						if ( abs( position.x ) >= ROOM_SIZE ) {

							velocity.velocity[ index * PARTICLE_SIZE + 0 ] = - velocity.velocity[ index * PARTICLE_SIZE + 0 ];

						}

						if ( abs( position.y ) >= ROOM_SIZE ) {

							velocity.velocity[ index * PARTICLE_SIZE + 1 ] = - velocity.velocity[ index * PARTICLE_SIZE + 1 ];

						}

						if ( abs( position.z ) >= ROOM_SIZE ) {

							velocity.velocity[ index * PARTICLE_SIZE + 2 ] = - velocity.velocity[ index * PARTICLE_SIZE + 2 ];

						}

						particle.particle[ index * PARTICLE_SIZE + 0 ] = position.x;
						particle.particle[ index * PARTICLE_SIZE + 1 ] = position.y;
						particle.particle[ index * PARTICLE_SIZE + 2 ] = position.z;
					}
				`;

				computeParams.push( {
					num: particleNum,
					shader: computeShader,
					bindings: computeBindings
				} );

				// Use a compute shader to animate the point cloud's vertex data.

				const boxSize = 0.1;
				const boxGeometry = new THREE.BoxBufferGeometry( boxSize, boxSize, boxSize );
				const geometry = new THREE.InstancedBufferGeometry()
					.setAttribute( 'position', boxGeometry.getAttribute( 'position' ) )
					.setAttribute( 'instancePosition', particleAttribute )
					.setAttribute( 'instanceColor', colorAttribute );
				geometry.setIndex( boxGeometry.getIndex() );
				geometry.instanceCount = particleNum;

				const material = new THREE.RawShaderMaterial( {
					vertexShader: `#version 450
						#define PARTICLE_NUM ${particleNum}
						#define PARTICLE_SIZE ${particleSize}

						layout(location = 0) in vec3 position;
						layout(location = 1) in vec3 instancePosition;
						layout(location = 2) in vec3 instanceColor;

						layout(location = 0) out vec3 vColor;

						layout(set = 0, binding = 0) uniform ModelUniforms {
							mat4 modelMatrix;
							mat4 modelViewMatrix;
							mat3 normalMatrix;
						} modelUniforms;

						layout(set = 0, binding = 1) uniform CameraUniforms {
							mat4 projectionMatrix;
							mat4 viewMatrix;
						} cameraUniforms;

						void main(){
							vColor = instanceColor;
							gl_Position = cameraUniforms.projectionMatrix * modelUniforms.modelViewMatrix * vec4( position + instancePosition, 1.0 );
						}
					`,
					fragmentShader: `#version 450
						#define PARTICLE_NUM ${particleNum}

						layout(location = 0) in vec3 vColor;
						layout(location = 0) out vec4 outColor;

						void main() {
							outColor = vec4( vColor, 1.0 );
						}
					`
				} );

				const bindings = [];

				const modelViewUniform = new Matrix4Uniform( 'modelMatrix' );
				const modelViewMatrixUniform = new Matrix4Uniform( 'modelViewMatrix' );
				const normalMatrixUniform = new Matrix3Uniform( 'normalMatrix' );

				const modelGroup = new WebGPUUniformsGroup( 'modelUniforms' );
				modelGroup.addUniform( modelViewUniform );
				modelGroup.addUniform( modelViewMatrixUniform );
				modelGroup.addUniform( normalMatrixUniform );
				modelGroup.setOnBeforeUpdate( function ( object/*, camera */ ) {

					modelViewUniform.setValue( object.matrixWorld );
					modelViewMatrixUniform.setValue( object.modelViewMatrix );
					normalMatrixUniform.setValue( object.normalMatrix );

				} );

				const projectionMatrixUniform = new Matrix4Uniform( 'projectionMatrix' );
				const viewMatrixUniform = new Matrix4Uniform( 'viewMatrix' );

				const cameraGroup = new WebGPUUniformsGroup( 'cameraUniforms' );
				cameraGroup.addUniform( projectionMatrixUniform );
				cameraGroup.addUniform( viewMatrixUniform );
				cameraGroup.setOnBeforeUpdate( function ( object, camera ) {

					projectionMatrixUniform.setValue( camera.projectionMatrix );
					viewMatrixUniform.setValue( camera.matrixWorldInverse );

				} );

				bindings.push( modelGroup );
				bindings.push( cameraGroup );

				material.bindings = bindings;

				const mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );

				renderer = new WebGPURenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				window.addEventListener( 'resize', onWindowResize, false );

				return renderer.init();

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				scene.rotation.x += 0.001;
				scene.rotation.y += 0.004;

				renderer.compute( computeParams );
				renderer.render( scene, camera );

			}

			function error( error ) {

				console.error( error );

			}

		</script>
	</body>
</html>
